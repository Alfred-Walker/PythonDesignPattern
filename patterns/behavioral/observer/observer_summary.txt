옵서버 패턴(observer pattern)

- 옵서버 패턴에서 객체(서브젝트)는 자식(옵서버)의 목록을 유지하며, 서브젝트가 옵서버에 정의된 메소드를 호출할 때마다 옵서버에 알린다.


예시

- 분산형 애플리케이션에서 여러 서비스들(옵서버)과 이를 관리하는 코어 서비스(서브젝트)

- 분산 시스템의 이벤트 서비스 구현

- 주식 시장 모델



목적

- 객체 간 일대다(1:N) 관계를 형성하고 객체의 상태를 다른 종속 객체에 자동으로 알린다.

- 서브젝트의 핵심 부분을 캡슐화한다.



옵서버 패턴 메소드

- 서브젝트의 변경 사항을 옵서버에 알리는 방법에는 푸시와 풀 두 가지 모델이 있다.


<풀 모델>
- 서브젝트는 변경 사항이 있음을 등록된 옵서버에 브로드캐스트한다.

- 옵서버는 직접 게시자에게 변경 사항을 요청하고 끌어와야(pull) 한다.

- 풀 모델은 서브젝트가 옵서버에 알리는 단계와 옵서버가 서브젝트로부터 필요한 데이터를 받아오는 두 단계가 필요하므로 비효율적이다.


<푸시 모델>

- 풀 모델과 달리 서브젝트가 옵서버에 데이터를 보낸다.

- 서브젝트는 옵서버가 필요로 하지 않는 데이터까지 보낼 수 있다. 따라서 쓸데없이 많은 양의 데이터를 전송해 응답 시간이 늦어질 수 있따.

- 성능을 위해 서브젝트는 오직 필요한 데이터만 보내야 한다.



옵서버 패턴과 느슨한 결합

- 언제든지 새로운 옵서버가 추가될 수 있다.

- 새로운 옵서버를 추가해도 서브젝트를 수정할 필요가 없다.

- 서브젝트 또는 옵서버는 독립적이며, 옵서버는 재사용될 수 있다.

- 서브젝트 또는 옵서버에 대한 수정이 서로에게 아무런 영향을 주지 않는다. (완전 독립성/느슨한 결합)


옵서버 패턴의 단점

- 제대로 구현되지 않은 옵서버 클래스는 복잡도를 높이고 성능 저하의 원인이 될 수 있다.

- 애플리케이션에서 알림 기능은 간혹 신뢰할 수 없으며, 레이스 상태(race condition) 또는 비일관성을 초래할 수 있다.