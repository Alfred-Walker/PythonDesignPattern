커맨드 패턴(command pattern)

- 커맨드 패턴은 객체가 특정 기능을 바로 수행하거나 나중에 트리거할 때 필요한 모든 정보를 캡슐화하는 행동 패턴이다.

- 메소드명/메소드를 소유하는 객체/메소드 인자 를 캡슐화한다.


예시 (인스톨 위저드, 프린터 스풀러 등)

- Command 객체를 통해 위저드나 스풀러 등을 실행하고 사용자가 단계별로 선택한 설정을 Command 객체에 저장한다.

- 사용자가 마지막에 Finish 버튼을 클릭하면 저장된 설정에 맞는 절차를 수행하는 함수를 호출한다. (execute(), print() 등)

=> 즉, 모든 설정을 추후에 함수를 호출할 객체 속에 캡슐화한다.



목적

- 요청을 객체 속에 캡슐화한다.

- 클라이언트의 다양한 요청을 매개변수화한다.

- 요청을 큐에 저장한다.

- 객체지향 콜백을 지원한다.



커맨드 패턴이 유용한 상황

- 수행할 명령에 따라 객체를 변수화할 때

- 요청을 큐에 저장하고 각기 다른 시점에 수행해야 하는 경우

- 작은 단위의 연산을 기반으로 하는 상위 연산을 만들 때



커맨드 패턴 설계

- 커맨드 패턴은 Command / ConcreteCommand / Client / Invoker / Receiver 의 5가지 객체로 구성된다.

- Command: ConcreteCommand 의 기반이 되는 추상 기본 클래스. 연산을 수행할 인터페이스를 정의한다.

- ConcreteCommand: Receiver 객체와 연산 간 바인딩을 정의한다.

- Client: ConcreteCommand 객체를 생성하고 Receiver 를 설정한다.

- Invoker: Receiver 에 처리를 요청하는 클래스. ConcreteCommand 의 Queue 를 관리하며 각 ConcreteCommand 에 수행을 요청한다.

- Receiver: 요청에 관련된 연산을 관리한다.



커맨드 패턴의 장점

- 작업을 요청하는 클래스와 실제 작업을 수행하는 클래스의 분리.

- 큐에 순서대로 저장되는 커맨드.

- 기존 코드의 수정 없이 새로운 커맨드를 쉽게 추가할 수 있다.

- 커맨드 패턴으로 리두(Redo)/롤백(Rollback) 가능한 시스템을 구현할 수 있다. (e.g. 해당 커맨드의 저장 및 순차 실행)



커맨드 패턴의 단점

- 클래스와 객체가 많다.

- 모든 작업이 독립적인 ConcreteCommand 클래스이므로 구현 및 유지보수해야 하는 클래스가 많다.